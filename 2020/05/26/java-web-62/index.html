<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="励志成为一位大佬">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    JRaft 线性读原理分析 |
    
    春少 Blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-java-web-62" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      JRaft 线性读原理分析
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/26/java-web-62/" class="article-date">
  <time datetime="2020-05-26T11:25:49.000Z" itemprop="datePublished">2020-05-26</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/JRaft/">JRaft</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="Raft-协议的读操作处理"><a href="#Raft-协议的读操作处理" class="headerlink" title="Raft 协议的读操作处理"></a>Raft 协议的读操作处理</h3><p><code>Raft</code>协议是一个强一致性协议。因此，在<code>T1</code>时刻发生的一个对于A数据的写操作通过<code>Raft</code>协议同步其他节点之后，在<code>T2</code>时刻发起的对A数据的读操作，一定能够读到被修改过的A的值。那么如果说按照传统的走<code>Raft Log</code>去实现读的话，其实是会对写操作请求有影响的，<code>Raft</code>协议本质是一个分布式日志复制状态机，所有的日志回放，最终都是在<code>StateMachine</code>里面单线程串行执行的。而实际上，读操作对应的<code>Raft Log</code>日志，无论它是串行还是并行，都不会对最终的数据有影响，因此，我们希望说，让<code>Raft StateMachine</code>尽可能的只处理涉及写操作的<code>Raft Log</code>，换句话说，就是我们在向<code>Raft</code>提交一个数据操作时，这个数据操作最好是对数据的写操作，而不是读操作。</p>
<p>既然说最好让<code>StateMachine</code>处理的<code>Raft Log</code>是数据的写操作，那么读请求该怎么处理？这里就要引出<code>Raft</code>针对读操作做出的优化了～</p>
<a id="more"></a>
<h4 id="Follower读"><a href="#Follower读" class="headerlink" title="Follower读"></a>Follower读</h4><p>因为<code>Raft Log</code>最终会同步到每个节点，每个节点在<code>StateMachine</code>内在顺序<code>Apply</code>每一个<code>Raft Log</code>，同时，在对<code>Raft Log</code>做<code>commit</code>以及<code>apply</code>的时候，每个节点内部会维护两个标识——<code>lastCommitedId</code>以及<code>lasrAppliedId</code>。Leader以及Follower，根据<code>commitedId</code>，可以知道当前<code>Follower</code>和<code>Leader</code>的已提交日志位点差距；通过<code>appliedId</code>，就可以知道<code>Follower</code>和<code>Leader</code>的已应用日志位点差距。而要实现<code>Follower</code>读，最最重要的的一个变量，就是这个<code>appliedId</code>。</p>
<h3 id="JRaft-怎么实现线性读的"><a href="#JRaft-怎么实现线性读的" class="headerlink" title="JRaft 怎么实现线性读的"></a>JRaft 怎么实现线性读的</h3><h4 id="使用JRaft发起线性读"><a href="#使用JRaft发起线性读" class="headerlink" title="使用JRaft发起线性读"></a>使用JRaft发起线性读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.readIndex(<span class="keyword">final</span> <span class="keyword">byte</span>[] requestContext, <span class="keyword">final</span> ReadIndexClosure done);</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>JRaft</code>的线性读能力就是这么简单，传入本次读操作的上下文<code>requestContext</code>以及当可以进行读操作时的回调函数<code>ReadIndexClosure</code>。</p>
<h4 id="内部怎么处理线性读的"><a href="#内部怎么处理线性读的" class="headerlink" title="内部怎么处理线性读的"></a>内部怎么处理线性读的</h4><p>当调用<code>Node.readIndex</code>的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readIndex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] requestContext, <span class="keyword">final</span> ReadIndexClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.ENODESHUTDOWN, <span class="string">"Node is shutting down."</span>));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node is shutting down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Requires.requireNonNull(done, <span class="string">"Null closure"</span>);</span><br><span class="line">    <span class="keyword">this</span>.readOnlyService.addRequest(requestContext, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前节点没有被关闭的化，则会将当前的读请求封装成一个<code>Event</code>通过<code>Disruptor</code>队列进行发布出去，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRequest</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] reqCtx, <span class="keyword">final</span> ReadIndexClosure closure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Utils.runClosureInThread(closure, <span class="keyword">new</span> Status(RaftError.EHOSTDOWN, <span class="string">"Was stopped"</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Service already shutdown."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里创建一个 EventTranslator 用于发布 ReadIndexEvent</span></span><br><span class="line">        EventTranslator&lt;ReadIndexEvent&gt; translator = (event, sequence) -&gt; &#123;</span><br><span class="line">                event.done = closure;</span><br><span class="line">                event.requestContext = <span class="keyword">new</span> Bytes(reqCtx);</span><br><span class="line">                event.startTime = Utils.monotonicMs();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于 Disruptor 内部是一个数组，采用 CAS 操作去判断是否可以塞入，如果不可以塞入，</span></span><br><span class="line">            <span class="comment">// 则会返回一个 False，因此这里需要判断是否插入成功</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.readIndexQueue.tryPublishEvent(translator)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果超出重试次数，则这里回调 closeure 报告失败，由上层决定具体操作</span></span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; MAX_ADD_REQUEST_RETRY_TIMES) &#123;</span><br><span class="line">                    Utils.runClosureInThread(closure,</span><br><span class="line">                            <span class="keyword">new</span> Status(RaftError.EBUSY, <span class="string">"Node is busy, has too many read-only requests."</span>));</span><br><span class="line">                    <span class="keyword">this</span>.nodeMetrics.recordTimes(<span class="string">"read-index-overload-times"</span>, <span class="number">1</span>);</span><br><span class="line">                    LOG.warn(<span class="string">"Node &#123;&#125; ReadOnlyServiceImpl readIndexQueue is overload."</span>, <span class="keyword">this</span>.node.getNodeId());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里进行线程的让出 CPU 动作，这里之所以不使用 Thread.Sleep()是因为JDK9开始新增的</span></span><br><span class="line">                <span class="comment">// onSpinWait其实现机制要比 Thread.Sleep的方式让出CPU要高效</span></span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        Utils.runClosureInThread(closure, <span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Node is down."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入<code>ReadIndexEvent</code>发布成功，则会进入到如下流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadIndexEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ReadIndexEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// task list for batch</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ReadIndexEvent&gt; events = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                                                      ReadOnlyServiceImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> ReadIndexEvent newEvent, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newEvent.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executeReadIndexEvents(<span class="keyword">this</span>.events);</span><br><span class="line">            <span class="keyword">this</span>.events.clear();</span><br><span class="line">            newEvent.shutdownLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于上层的事件发布可能存在批量发布的操作，因此这里会做一个任务攒批的操作</span></span><br><span class="line">        <span class="keyword">this</span>.events.add(newEvent);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.events.size() &gt;= ReadOnlyServiceImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch() || endOfBatch) &#123;</span><br><span class="line">            <span class="comment">// 执行 ReadIndexEvent</span></span><br><span class="line">            executeReadIndexEvents(<span class="keyword">this</span>.events);</span><br><span class="line">            <span class="keyword">this</span>.events.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前是批量事件发布的最后一个事件或者当前任务的暂存个数已经达到了最大的批处理数量，因此要开始处理<code>ReadIndexEvent</code>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeReadIndexEvents</span><span class="params">(<span class="keyword">final</span> List&lt;ReadIndexEvent&gt; events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线性读请求</span></span><br><span class="line">    <span class="keyword">final</span> ReadIndexRequest.Builder rb = ReadIndexRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">            .setGroupId(<span class="keyword">this</span>.node.getGroupId()) <span class="comment">//</span></span><br><span class="line">            .setServerId(<span class="keyword">this</span>.node.getServerId().toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;ReadIndexState&gt; states = <span class="keyword">new</span> ArrayList&lt;&gt;(events.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行请求体构建</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ReadIndexEvent event : events) &#123;</span><br><span class="line">        rb.addEntries(ZeroByteStringHelper.wrap(event.requestContext.get()));</span><br><span class="line">        states.add(<span class="keyword">new</span> ReadIndexState(event.requestContext, event.done, event.startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ReadIndexRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC调用处理 ReadIndexRequest</span></span><br><span class="line">    <span class="keyword">this</span>.node.handleReadIndexRequest(request, <span class="keyword">new</span> ReadIndexResponseClosure(states, request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，这里会调用<code>Node.handleReadIndexRequest</code>去开始真正处理读请求操作了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReadIndexRequest</span><span class="params">(<span class="keyword">final</span> ReadIndexRequest request, <span class="keyword">final</span> RpcResponseClosure&lt;ReadIndexResponse&gt; done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> STATE_LEADER:</span><br><span class="line">                <span class="comment">// 如果当前节点是 Leader 节点，则走 Leader 读的方式</span></span><br><span class="line">                readLeader(request, ReadIndexResponse.newBuilder(), done);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STATE_FOLLOWER:</span><br><span class="line">                <span class="comment">// 如果当前节点是 Follower 节点，则走 Follower 读的方式（重点）</span></span><br><span class="line">                readFollower(request, done);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STATE_TRANSFERRING:</span><br><span class="line">                <span class="comment">// 当前正在发生选主过程，无法满足线性读的要求</span></span><br><span class="line">                done.run(<span class="keyword">new</span> Status(RaftError.EBUSY, <span class="string">"Is transferring leadership."</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                done.run(<span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Invalid state for readIndex: %s."</span>, <span class="keyword">this</span>.state));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">        <span class="keyword">this</span>.metrics.recordLatency(<span class="string">"handle-read-index"</span>, Utils.monotonicMs() - startMs);</span><br><span class="line">        <span class="keyword">this</span>.metrics.recordSize(<span class="string">"handle-read-index-entries"</span>, request.getEntriesCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当处理<code>ReadIndexEvent</code>的时候，会根据当前节点的状态进行判断怎么处理这个线性读的请求，首先来看下，如果当前节点是Leader节点的怎么处理的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readLeader</span><span class="params">(<span class="keyword">final</span> ReadIndexRequest request, <span class="keyword">final</span> ReadIndexResponse.Builder respBuilder,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> RpcResponseClosure&lt;ReadIndexResponse&gt; closure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> quorum = getQuorum();</span><br><span class="line">    <span class="comment">// 如果当前过半的节点数量小于等1，表明目前集群成员只有一个节点，快速结束读请求，直接返回成功</span></span><br><span class="line">    <span class="keyword">if</span> (quorum &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Only one peer, fast path.</span></span><br><span class="line">        respBuilder.setSuccess(<span class="keyword">true</span>) <span class="comment">//</span></span><br><span class="line">                .setIndex(<span class="keyword">this</span>.ballotBox.getLastCommittedIndex());</span><br><span class="line">        closure.setResponse(respBuilder.build());</span><br><span class="line">        closure.run(Status.OK());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前最新的 committedIndex 位点信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lastCommittedIndex = <span class="keyword">this</span>.ballotBox.getLastCommittedIndex();</span><br><span class="line">    <span class="comment">// 根据当前的 lastCommittedIndex 获取对应的任期信息，判断是否等自己的任期，如果不想等，则说明</span></span><br><span class="line">    <span class="comment">// 自己在这个任期之内还没有 committed 任何日志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logManager.getTerm(lastCommittedIndex) != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">        <span class="comment">// Reject read only request when this leader has not committed any log entry at its term</span></span><br><span class="line">        closure</span><br><span class="line">                .run(<span class="keyword">new</span> Status(</span><br><span class="line">                    RaftError.EAGAIN,</span><br><span class="line">                    <span class="string">"ReadIndex request rejected because leader has not committed any log entry at its term, logIndex=%d, currTerm=%d."</span>,</span><br><span class="line">                    lastCommittedIndex, <span class="keyword">this</span>.currTerm));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    respBuilder.setIndex(lastCommittedIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是从 Follower 节点或者 Learner 节点发起的读请求，则需要判断他们在不在当前的Raft Conf里面</span></span><br><span class="line">    <span class="keyword">if</span> (request.getPeerId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// request from follower or learner, check if the follower/learner is in current conf.</span></span><br><span class="line">        <span class="keyword">final</span> PeerId peer = <span class="keyword">new</span> PeerId();</span><br><span class="line">        peer.parse(request.getServerId());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.contains(peer) &amp;&amp; !<span class="keyword">this</span>.conf.containsLearner(peer)) &#123;</span><br><span class="line">            closure</span><br><span class="line">                    .run(<span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Peer %s is not in current configuration: %s."</span>, peer, <span class="keyword">this</span>.conf));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要获取当前线性读的设置，是采用心跳确认机制还是使用Leader租约机制确认</span></span><br><span class="line">    ReadOnlyOption readOnlyOpt = <span class="keyword">this</span>.raftOptions.getReadOnlyOptions();</span><br><span class="line">    <span class="keyword">if</span> (readOnlyOpt == ReadOnlyOption.ReadOnlyLeaseBased &amp;&amp; !isLeaderLeaseValid()) &#123;</span><br><span class="line">        <span class="comment">// If leader lease timeout, we must change option to ReadOnlySafe</span></span><br><span class="line">        readOnlyOpt = ReadOnlyOption.ReadOnlySafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (readOnlyOpt) &#123;</span><br><span class="line">        <span class="comment">// 线性安全读的模式，需要向所有的成员发送心跳信息</span></span><br><span class="line">        <span class="keyword">case</span> ReadOnlySafe:</span><br><span class="line">            <span class="keyword">final</span> List&lt;PeerId&gt; peers = <span class="keyword">this</span>.conf.getConf().getPeers();</span><br><span class="line">            Requires.requireTrue(peers != <span class="keyword">null</span> &amp;&amp; !peers.isEmpty(), <span class="string">"Empty peers"</span>);</span><br><span class="line">            <span class="comment">// 这个 Closure 内部会有ack机制，如果过半的节点确认自己是 Leader，则触发回调允许线性读的发生</span></span><br><span class="line">            <span class="keyword">final</span> ReadIndexHeartbeatResponseClosure heartbeatDone = <span class="keyword">new</span> ReadIndexHeartbeatResponseClosure(closure,</span><br><span class="line">                    respBuilder, quorum, peers.size());</span><br><span class="line">            <span class="comment">// Send heartbeat requests to followers</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : peers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.replicatorGroup.sendHeartbeat(peer, heartbeatDone);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 这里直接使用 Leader 的租约机制来快速判断自己是否还是Leader，该模式是最快的，但是也是对时钟的要求最高的，这里需要确保每个节点的时钟都一致。</span></span><br><span class="line">        <span class="keyword">case</span> ReadOnlyLeaseBased:</span><br><span class="line">            <span class="comment">// Responses to followers and local node.</span></span><br><span class="line">            respBuilder.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">            closure.setResponse(respBuilder.build());</span><br><span class="line">            closure.run(Status.OK());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，当<code>ReadIndexRequest</code>被Leader处理的时候，会去通过一系列的规则去判断当前的读请求能否去执行，并且需要通过心跳机制或者<code>Leader</code>租约机制进行判断当前的Leader是否真的是Leader。</p>
<p>那么，如果读请求是<code>Follower</code>发起的，那么是怎么处理的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFollower</span><span class="params">(<span class="keyword">final</span> ReadIndexRequest request, <span class="keyword">final</span> RpcResponseClosure&lt;ReadIndexResponse&gt; closure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.leaderId == <span class="keyword">null</span> || <span class="keyword">this</span>.leaderId.isEmpty()) &#123;</span><br><span class="line">        closure.run(<span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"No leader at term %d."</span>, <span class="keyword">this</span>.currTerm));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send request to leader.</span></span><br><span class="line">    <span class="keyword">final</span> ReadIndexRequest newRequest = ReadIndexRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">            .mergeFrom(request) <span class="comment">//</span></span><br><span class="line">            .setPeerId(<span class="keyword">this</span>.leaderId.toString()) <span class="comment">//</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">this</span>.rpcService.readIndex(<span class="keyword">this</span>.leaderId.getEndpoint(), newRequest, -<span class="number">1</span>, closure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就要看<code>ReadIndexResponseClosure</code>这个类了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadIndexResponseClosure</span> <span class="keyword">extends</span> <span class="title">RpcResponseClosureAdapter</span>&lt;<span class="title">ReadIndexResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;ReadIndexState&gt; states;</span><br><span class="line">    <span class="keyword">final</span> ReadIndexRequest     request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadIndexResponseClosure</span><span class="params">(<span class="keyword">final</span> List&lt;ReadIndexState&gt; states, <span class="keyword">final</span> ReadIndexRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.states = states;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里会等待向Leader发送的读请求的返回。</span></span><br><span class="line"><span class="comment">     * 注意，由于在 Follower 发起的读请求，最终需要从 Leader 获取 Leader 当前最新的 commited index</span></span><br><span class="line"><span class="comment">     * 位点信息，并且需要等待自己的状态机回放日志到该位点，因此，这一段的时间是不可知的，有可能需要等待很长的</span></span><br><span class="line"><span class="comment">     * 时间，因此建议使用者最好加上读取超时时间，然后采用 Leader 读作为兜底机制。尽可能的让读取数据操作</span></span><br><span class="line"><span class="comment">     * 成功。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果读失败，通知所有读请求的回调告知失败。</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">            notifyFail(status);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ReadIndexResponse readIndexResponse = getResponse();</span><br><span class="line">        <span class="keyword">if</span> (!readIndexResponse.getSuccess()) &#123;</span><br><span class="line">            notifyFail(<span class="keyword">new</span> Status(-<span class="number">1</span>, <span class="string">"Fail to run ReadIndex task, maybe the leader stepped down."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前Leader返回的 index 位点信息</span></span><br><span class="line">        <span class="keyword">final</span> ReadIndexStatus readIndexStatus = <span class="keyword">new</span> ReadIndexStatus(<span class="keyword">this</span>.states, <span class="keyword">this</span>.request,</span><br><span class="line">                readIndexResponse.getIndex());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ReadIndexState state : <span class="keyword">this</span>.states) &#123;</span><br><span class="line">            <span class="comment">// Records current commit log index.</span></span><br><span class="line">            state.setIndex(readIndexResponse.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">        ReadOnlyServiceImpl.<span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断当前 Follower 的状态机是否已经 apply 到了 Leader 传回来的 index 位点位置</span></span><br><span class="line">            <span class="keyword">if</span> (readIndexStatus.isApplied(ReadOnlyServiceImpl.<span class="keyword">this</span>.fsmCaller.getLastAppliedIndex())) &#123;</span><br><span class="line">                <span class="comment">// 如果当前的状态机回放日志的位点已经达到或者超过了 Leader 回传的 Index，</span></span><br><span class="line">                <span class="comment">// 则通知所有线性读回调函数可以正确执行了。</span></span><br><span class="line">                ReadOnlyServiceImpl.<span class="keyword">this</span>.lock.unlock();</span><br><span class="line">                doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                notifySuccess(readIndexStatus);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果还没有回放到对应的日志位点的话，需要将当前的信息进行暂存在一个队列中。</span></span><br><span class="line">                ReadOnlyServiceImpl.<span class="keyword">this</span>.pendingNotifyStatus</span><br><span class="line">                    .computeIfAbsent(readIndexStatus.getIndex(), k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>)) <span class="comment">//</span></span><br><span class="line">                    .add(readIndexStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">                ReadOnlyServiceImpl.<span class="keyword">this</span>.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyFail</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowMs = Utils.monotonicMs();</span><br><span class="line">        <span class="comment">// 通知所有在等待的线性读请求，可以进行读请求的执行了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ReadIndexState state : <span class="keyword">this</span>.states) &#123;</span><br><span class="line">            ReadOnlyServiceImpl.<span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">"read-index"</span>, nowMs - state.getStartTimeMs());</span><br><span class="line">            <span class="keyword">final</span> ReadIndexClosure done = state.getDone();</span><br><span class="line">            <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Bytes reqCtx = state.getRequestContext();</span><br><span class="line">                done.run(status, ReadIndexClosure.INVALID_LOG_INDEX, reqCtx != <span class="keyword">null</span> ? reqCtx.get() : <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是<code>JRaft</code>实现的线性读机制。接下来我贴一下我在<code>nacos-1.3.0-beta</code>对<code>JRaft</code>读操作的设计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Response&gt; <span class="title">get</span><span class="params">(<span class="keyword">final</span> GetRequest request)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> String group = request.getGroup();</span><br><span class="line">	CompletableFuture&lt;Response&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">	<span class="keyword">final</span> RaftGroupTuple tuple = findTupleByGroup(group);</span><br><span class="line">	<span class="keyword">if</span> (Objects.isNull(tuple)) &#123;</span><br><span class="line">		future.completeExceptionally(<span class="keyword">new</span> NoSuchRaftGroupException(group));</span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> Node node = tuple.node;</span><br><span class="line">	<span class="keyword">final</span> LogProcessor processor = tuple.processor;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		node.readIndex(BytesUtil.EMPTY_BYTES, <span class="keyword">new</span> ReadIndexClosure() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Status status, <span class="keyword">long</span> index, <span class="keyword">byte</span>[] reqCtx)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isOk()) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Response response = processor.onRequest(request);</span><br><span class="line">						future.complete(response);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">						MetricsMonitor.raftReadIndexFailed();</span><br><span class="line">						future.completeExceptionally(<span class="keyword">new</span> ConsistencyException(<span class="string">"The conformance protocol is temporarily unavailable for reading"</span>, t));</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				MetricsMonitor.raftReadIndexFailed();</span><br><span class="line">				Loggers.RAFT.error(<span class="string">"ReadIndex has error : &#123;&#125;"</span>, status.getErrorMsg());</span><br><span class="line">				future.completeExceptionally(</span><br><span class="line">						<span class="keyword">new</span> ConsistencyException(<span class="string">"The conformance protocol is temporarily unavailable for reading, "</span> + status.getErrorMsg()));</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		MetricsMonitor.raftReadFromLeader();</span><br><span class="line">		Loggers.RAFT.warn(<span class="string">"Raft linear read failed, go to Leader read logic : &#123;&#125;"</span>, e.toString());</span><br><span class="line">		<span class="comment">// run raft read</span></span><br><span class="line">		readFromLeader(request, future);</span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromLeader</span><span class="params">(<span class="keyword">final</span> GetRequest request,<span class="keyword">final</span> CompletableFuture&lt;Response&gt; future)</span> </span>&#123;</span><br><span class="line">	commit(request.getGroup(), request, future)</span><br><span class="line">			.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Response, Throwable&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Response response, Throwable throwable)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">if</span> (Objects.nonNull(throwable)) &#123;</span><br><span class="line">						future.completeExceptionally(<span class="keyword">new</span> ConsistencyException(<span class="string">"The conformance protocol is temporarily unavailable for reading"</span>, throwable));</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (response.getSuccess()) &#123;</span><br><span class="line">						future.complete(response);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						future.completeExceptionally(</span><br><span class="line">								<span class="keyword">new</span> ConsistencyException(<span class="string">"The conformance protocol is temporarily unavailable for reading, "</span> + response.getErrMsg()));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="https://www.liaochuntao.cn/2020/05/26/java-web-62/" data-id="ckbai2qe6005c16oltbqv0xuf" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JRaft/">JRaft</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2020/06/03/java-web-63/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            Etcd3 租约机制解析
          
        </div>
      </a>
    
    
      <a href="/2020/05/22/java-web-61/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">JRaft里面的时间轮算法</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 春少 Blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="春少 Blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-50},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>